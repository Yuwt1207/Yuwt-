543





# 算法

## 排序

### 十个经典排序：https://www.cnblogs.com/onepixel/p/7674659.html

![](https://uploadfiles.nowcoder.com/images/20190319/242025553_1552989593064_E70A7C7F55EE4951924DEBF98CC9513D)

![](https://uploadfiles.nowcoder.com/images/20190219/242025553_1550564529306_DF5F4A0D06D13185C873BE851CBF7E9F)

- 冒泡排序

- 插入排序

- 选择排序

- 希尔排序

- 归并排序

- 快速排序
    - 快排的阶段性排序结果的特点是，第i趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，它右边的数都比它大。
    - 若每次选择第一个或最后一个元素为pivot，快排在完全无序的情况下效果最好，时间复杂度为O(nlogn);在已排序的情况下效果最差，时间复杂度为O(n^2)。
    - 几种优化方法:https://www.cnblogs.com/algorithm-process/p/11967173.html
      - 三点中值法:每次选pivot的时候在左边界、右边界、中间下标三者选中间值作为新的pivot
      - 绝对中值法:把数组分为每n(这里选择5)个一组，不足的也作为一组，每组求中间值，再对这些中间值求中间值，最后得到的中间值作为pivot。但这种方法求中间值还需要O(n)时间，故一般使用三点中值法优化。
      - 当需要排序的元素个数小于8个时，插入排序更快
    - 每次优先处理短的分区可以减小递归栈的深度
    
- 堆排序
    - https://www.cnblogs.com/chengxiao/p/6129630.html
    - 建堆的时间复杂度为O(n)
    
- 计数排序

- 桶排序

- 基数排序

- 关于几种排序的稳定性的解释:

    - (1)冒泡排序

        冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。

    - (2)选择排序

        选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

    - (3)插入排序

        插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。

    - (4)快速排序

        快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。

    - (5)归并排序

        归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

    - (6)基数排序

        基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

    - (7)希尔排序(shell)

        希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

    - (8)堆排序

        我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

    - 综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。
### 外部排序
- 定义：外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序。
- 置换选择排序算法:http://data.biancheng.net/view/78.html
    - 胜者树与败者树:https://blog.csdn.net/whz_zb/article/details/7425152
### 拓扑排序:https://www.cnblogs.com/bigsai/p/11489260.html
### 枚举排序  ?



## 查找

### BFPRT算法

- 相关资料：https://segmentfault.com/a/1190000008322873

- 简介：在一个数组中求其前 k 大或前 k 小的问题，简称 TOP-K 问题。而目前解决 TOP-K 问题最有效的算法即是**BFPRT 算法**，



## 存储

### 链式存储（如链表）和顺序存储（如数组）

- 使用特点
  - 顺序表适宜于做查找这样的静态操作；
  - 链表宜于做插入、删除这样的动态操作。
  - 若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；
  - 若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。

- **基于空间的比较**
  - 存储分配的方式
    - 顺序表的存储空间是静态分配的
    - 链表的存储空间是动态分配的
  - 存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量
    - 顺序表的存储密度 = 1
    - 链表的存储密度 < 1
- **基于时间的比较**
  - 存取方式
    - 顺序表可以随机存取，也可以顺序存取
    - 链表是顺序存取的
  - 插入/删除时移动元素个数
    - 顺序表平均需要移动近一半元素
    - 链表不需要移动元素，只需要修改指针

## 字符串模式匹配

### KMP算法

- 相关题目和代码:https://leetcode-cn.com/problems/implement-strstr/submissions/
- 参考资料:https://blog.csdn.net/dark_cy/article/details/88698736
- KMP算法在进行模式匹配前，先扫描一遍模式串,对于每模式串 t 的每个元素 t j，都存在一个实数 k ，使得模式串 t 开头的 k 个字符（t 0 t 1…t k-1）依次与 t j 前面的 k（t j-k t j-k+1…t j-1，这里第一个字符 t j-k 最多从 t 1 开始，所以 k < j）个字符相同。如果这样的 k 有多个，则取最大的一个。模式串 t 中每个位置 j 的字符都有这种信息，采用 next 数组表示，即 next[ j ]=MAX{ k }。
- ![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190322194629884.png)

- 如上图所示，即对于第j个字符，它前面的k个字符[j-k,j-1]和[0,k-1]的字符串完全匹配，此时如果第j个字符匹配失败，不需要回溯到开头位置，只需要回溯到k位置就可以再次进行匹配

  

## 其他

### 素数线性筛法

- 相关题目:https://leetcode-cn.com/problems/count-primes/submissions/
- 相关资料:https://leetcode-cn.com/problems/count-primes/solution/ru-he-gao-xiao-pan-ding-shai-xuan-su-shu-by-labula/
- 应用场景:给定一个正整数n，返回小于n的整数中，有多少个质数
- 大概思路:对于一个数，不论他是不是质数，它的倍数一定是个质数，所以先将每个数的倍数全部标记为质数，用一个bool数组来保存，排除了所有非质数后，即可算出有多少个质数

### 最大公约数

```c++
int gcd(int a,int b)  
{  
	int r;  
	while(b>0)  
    {  
        r=a%b;  
        a=b;  
        b=r;  
    }  
    return a;  
 }  
```

### 最小公倍数

- 最小公倍数为两数乘积除最大公约数

# 数据结构

## 二叉搜索树（Binary Search Tree,BST)

- 二叉搜索树的性质：左子树上的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值，如果采用先序遍历则获得的是一个递增的数组。







# SFML

## 什么是SFML

  - SFML 是多媒体库，它为PC的各个组件提供简单的界面，用来简化游戏和多媒体应用程序的开发。 主要由五个模块组成，分别是：系统，窗口，图形，音频和网络。

  - SFML 是跨平台的，通过 SFML，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS以及Android和iOS。

  - SFML 支持多种语言，具体可以在官网查看支持的语言。

    
    

# C++相关
## 类
### 友元函数
- 参考资料:https://www.runoob.com/cplusplus/cpp-friend-functions.html
- 简介:友元函数是定义在类的外部的一个函数，但是可以访问类内的成员，友元函数本身并不是类的成员！！同理还有友元类。使用时在函数前带上friend关键字。

### 内联函数

- 参考资料:https://www.runoob.com/cplusplus/cpp-inline-functions.html
- 简介:内联函数通常与类一起使用，内联函数在编译时，编译器会把该函数出现的地方直接替换为函数的代码段，所以内联函数通常为10行内的小函数，使用时在函数名前带上inline关键字，在类里面定义的成员函数是内联函数，虽然没有inline关键字。注意：内联函数中不要出现递归，循环和开关语句。虚函数和递归函数不能被正常内联
- 优点:函数体较小时，能提高代码效率，对于代码较少的函数推荐使用内联
- 缺点:如果内联函数代码较多，则可能使程序变慢

### 静态成员

- 参考资料:https://www.runoob.com/cplusplus/cpp-static-members.html
- 简介:当类定义中的一个成员是静态成员时，那么无论我们创建多少个该类的对象，静态成员始终只有一个，类似于全局变量，即该类的不同对象访问的是同一个静态成员，不同对象共享一个静态成员。静态成员可以在类的外部通过::来重新初始化该静态成员。使用时在成员前带上static关键字。
- 静态成员函数
  - 静态成员函数即使在没有类的实例对象时也可以调用，方法为: 类名::静态成员函数名
  - 静态成员函数只能访问静态成员数据和其他静态成员函数和类外的其他函数
  - 静态成员函数没有this指针

### 多态

- 参考资料:https://www.runoob.com/cplusplus/cpp-polymorphism.html
- 简介:当子类和父类都有一个同名函数时，对应的子类调用自己类中的这个函数，是多态的一般使用方式。

####    虚函数

- 简介:**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

- 没有主体的虚函数是纯虚函数，这时要在声明后加上"=0",例:virtual int getarea()=0;

  | 摘自别人的笔记:                                              |
  | ------------------------------------------------------------ |
  | 1、纯虚函数声明如下： **virtual void funtion1()=0;** 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。<br />2、虚函数声明如下：**virtual ReturnType FunctionName(Parameter)** 虚函数必须实现，如果不实现，编译器将报错，错误提示为：<br />error LNK\****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"<br />3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。<br />4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。<br />5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。<br />6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。<br />7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。<br />8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。 |

- 补充:C++中，虚函数可以是private的，并且可以被子类所覆盖，但是子类不能调用父类中private的虚函数。

- | 摘自别人的笔记                                               |
  | ------------------------------------------------------------ |
  | C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。<br />一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。<br />编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！<br />**纯虚函数**可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。 |

### 抽象类

- 参考资料:https://www.runoob.com/cplusplus/cpp-interfaces.html

- 简介:如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。

- 设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的**基类**。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。

  因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。

  可用于实例化对象的类被称为**具体类**。

### 其他

- 空类的大小为1
  - 原因是类也可以实例化，类实例化出的每个对象都需要有不同的内存地址，为了使每个对象在内存中的地址不同，所以会在类中加入一个隐含的字节

- 类和结构体的区别
  - 区别在于结构体和类具有不同的默认访问属性
  - 类成员的默认访问属性为private
  - 结构体默认为public
  - C中空结构体的大小是0，C++中空结构体的大小为1（视为空类）

## 异常处理

- 相关资料:https://www.runoob.com/cplusplus/cpp-exceptions-handling.html



## 命名空间

- 相关资料:https://www.runoob.com/cplusplus/cpp-namespaces.html



## 模板

- 相关资料:https://www.runoob.com/cplusplus/cpp-templates.html
- 类似容器vector\<type>,这里type告诉编译器这是个放什么类型元素的容器，template\<class type>提前标注type，在函数声明时，如type  Max (type const& a, type const& b) ，在调用函数时type自动对应于传入的参数a，b的类型。（type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。）
- 关于typename和class的区别![image-20200507210942195](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200507210942195.png)

- 除了函数模板，还能定义类模板

## 其他

- const关键字
  - 在成员函数后加const关键字，表示该函数不会修改类的成员变量，如果尝试修改，则编译器会直接报错，使用const可以提高程序的可靠性
  - 使用示例:someclass::int somefun() const



## 容器

### string字符串

#### 运算符的比较

- string类变量的>,<,>=,<=比的是第一个不同的字符的大小，如aba>aab
- 如果一个string和另一个string的前一串字符完全一样，则长的string大，如abb>a
- 用运算符比较string时，两边的string都不能是null，否则程序会退出
- string的length()和size()方法返回的是unsigned int，vector的size方法返回的也是unsigned int，如果与负数相比较，先用一个int接一下再比较



### vector

- 一些参考资料:
  - https://blog.csdn.net/u012658346/article/details/50725933?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase
- vector的结构

  - vector是连续存储的，在内存空间中，vector的元素是连续的，所以随机访问的时间复杂度为常数

  - vector在分配内存时会分配比需要的内存更大一些，为了减少二次分配的可能性
  - 大概理解是三个指针
    - _myfirst指向栈底，是分配空间的起始位置
    - _mylast指向最后一个元素的位置
    - _myend指向分配空间的最后的位置
    - ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20160223191226316)
    - 大致结构如上图所示
  - vector的两个重要大小
    - size:   size=_mylast-\_myfirst,是用户已使用的大小
    - capacity:  capacity=_myend-\_myfirst,是程序真正分配的内存的大小
- vector的扩容

  - 当vector的容量不足时继续insert数据，就会触发vector的扩容，在VS下，vector会扩容为原来的150%，即capacity=1.5capacity,若仍然不足则capacity=capacity+count,count为要插入的元素的数量，所以扩容后仍会流出一定空间
  - 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。
  - 扩容时，vector会重新申请一块内存空间，然后将原有数据copy过去，之后释放原来的内存空间
  - 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 
  - shrink_to_fit()函数可以动态释放内存，让capacity和size相等。
  - 参考资料:https://blog.csdn.net/yangshiziping/article/details/52550291?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-9.nonecase
- vector的插入（空间足够时）
  - 当被插入的元素位置比较靠近_mylast指针时，将插入位置往后的所有元素向后移动，流出被插入元素数量的大小的空间，然后从\_mylast处填充被插入的元素
  - 
- vector的删除erase操作
  - 将要删除的元素的后面的元素向前copy，然后将后面的空余空间释放，并更新_mylast变量
  - ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20160223203457456)
- vector的清空clear操作
  - 清空所有元素但是不会回收已分配的空间

- vector其他的清空方法
  - swap函数
    - swap函数相当于交换两个vector的指针，即v1原本是（a，b）空间的，v2原本是(c,d)空间的，swap之后，v1是指向(c,d)空间的,v2是指向(a,b)空间的，两个vector中的元素没有移动，只是指向两个vector的指针移动了
    - swap通过构造一个空vector来与原vector交换，来清空vector
    - swap后原来的迭代器指向的位置还是不变，由此可以看出vector中的元素是没有改变的
  - shrink_to_fit函数
    - 大概原理是动态释放size到capacity这部分的内存，最后capacity=size

## 其他

- 不同数据类型所占的字节

  - | 单位为字节 | char | short | int  | long | 指针/void指针 |
    | ---------- | ---- | ----- | ---- | ---- | ------------- |
    | 32位机器   | 1    | 2     | 4    | 4    | 4/4           |
    | 64位机器   | 1    | 2     | 4    | 8    | 8/4           |

- new/delete和malloc/free的区别

  - 使用new时，先分配一块内存空间，然后调用类的构造函数，初始化各个成员变量，而malloc只做到了分配空间

  - new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。
  - 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
  -  new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
  - new会先调用operator new函数，申请足够的内存（**通常底层使用malloc实现**）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（**通常底层使用free实现**）。
    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

  -  new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。
    new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
  - new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
  - 内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc却不可以。

- void\*指针
  - void\*不指向任何数据类型，它属于一种未确定类型的过渡型数据，因此如果要访问实际存在的数据，必须将void*指针强转成为指定一个确定的数据类型的数据，如int*、string*等。void*指针只支持几种有限的操作：与另一个指针进行比较；向函数传递void*指针或从函数返回void*指针；给另一个void*指针赋值。不允许使用void*指针操作它所指向的对象，例如，不允许对void*指针进行解引用。不允许对void*指针进行算术操作。
  
- 除法取整
  
  - int的除法对于正数最后直接去掉小数部分取整，如5/3=1，而负数的取整取决于编译器
  - 若规定向上或向下取整，则使用floor(向下)和ceil(向上)函数
  
- 判断字母或数字

  - isalpha:判断一个字符是否为字母
  - isalnum:判断一个字符是否是字母或数字,即判断是否为a~z||A~Z||0~9
  - islower:判断字符是否为小写，如果不是字母，则返回0
  - isupper:判断字符是否为大写，如果不是字母，则返回0

- 大小写的转换

  - toupper:将字符转换为大写
  - tolower:将字符转换为小写
  - 以上两个函数的输入都只能是一个字符

- int转string函数

  - to_string(int num)



# 操作系统

### 进程

- 进程间的通信方式
  - 管道
    - 本质是文件
    - 大小为4096字节
    - 管道满时写阻塞，空时读阻塞
    - 相当于一个缓冲区，一个进程往里写，一个进程往外读
    - 管道一般设计为环形，以便重复利用
    - 可以通过两个方向相反的管道实现双向通信
    - 两个进程都终结时，管道消失
    - 只能在父子进程间通信，但命名管道可以在任意进程间通信
  - 消息队列
    - 消息的链表，存放在内核中，一个消息队列由一个标识符(队列ID)来标识
  - 信号量
    - 本质是计数器
    - 进程访问临界资源时，需要检测信号量，若为正数，则信号量减1且进程进入临界区执行，若为负数，则进程挂起进入等待队列，直到有其他进程释放了资源信号量加1且信号量达到正数时重新唤醒
  - 共享内存
    - 两个及以上的进程共同分享同一块内存空间
    - 共享内存时最快的进程间通信方式，因为不同进程不需要通过执行进入内核的系统调用来传递彼此的数据，它们可以直接在内存空间中操作



### 线程

- 线程间的通信方式
  - 如果是两个进程的两个线程间通信，则等同于两个进程通信
  - 全局变量
    - 需要在变量前加关键字volatile
    - volatile:每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取
  - 互斥量
  - 信号量
  - 事件
  - 临界区

- 线程可以共享进程的资源包括
  - **进程代码段**、**进程的公有数据**(利用这些共享的数据，线程很容易的实现相互之间的通讯)、**进程打开的文件描述符**、**信号的处理器**、**进程的当前目录**和**进程用户ID**与**进程组ID**。
  - 不共享的包括：**线程ID，寄存器组的值，线程的堆栈，错误返回码， 线程的信号屏蔽码， 线程的优先级**

# android studio相关

## 数据库相关

### 增删改查，建库

- 参考资料:https://blog.csdn.net/weixin_42247720/article/details/92852844



# python

## 一些有用的库

- nltk:英文文本处理
- jieba:中文文本处理
- pynlpir:中文文本处理
- matplotlib:类似matlab的库
- 使用pip安装时速度过慢时，国内镜像站：
  - 豆瓣：http://pypi.douban.com/simple/ 
  - 清华：https://pypi.tuna.tsinghua.edu.cn/simple
  - 使用方式为:pip install -i https://pypi.tuna.tsinghua.edu.cn/simple  [pakagename]