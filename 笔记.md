# 算法

## 排序

### 十个经典排序：https://www.cnblogs.com/onepixel/p/7674659.html

![](https://uploadfiles.nowcoder.com/images/20190319/242025553_1552989593064_E70A7C7F55EE4951924DEBF98CC9513D)

![](https://uploadfiles.nowcoder.com/images/20190219/242025553_1550564529306_DF5F4A0D06D13185C873BE851CBF7E9F)

- 冒泡排序
- 插入排序
- 选择排序
- 希尔排序
- 归并排序
- 快速排序
    - 快排的阶段性排序结果的特点是，第i趟完成时，会有i个以上的数出现在它最终将要出现的位置，即它左边的数都比它小，它右边的数都比它大。
    - 若每次选择第一个或最后一个元素为pivot，快排在完全无序的情况下效果最好，时间复杂度为O(nlogn);在已排序的情况下效果最差，时间复杂度为O(n^2)。
    - 几种优化方法:https://www.cnblogs.com/algorithm-process/p/11967173.html
      - 三点中值法:每次选pivot的时候在左边界、右边界、中间下标三者选中间值作为新的pivot
      - 绝对中值法:把数组分为每n(这里选择5)个一组，不足的也作为一组，每组求中间值，再对这些中间值求中间值，最后得到的中间值作为pivot。但这种方法求中间值还需要O(n)时间，故一般使用三点中值法优化。
      - 当需要排序的元素个数小于8个时，插入排序更快
    - 每次优先处理短的分区可以减小递归栈的深度
- 堆排序
    - https://www.cnblogs.com/chengxiao/p/6129630.html
- 计数排序
- 桶排序
- 基数排序
### 外部排序
- 定义：外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序。
- 置换选择排序算法:http://data.biancheng.net/view/78.html
    - 胜者树与败者树:https://blog.csdn.net/whz_zb/article/details/7425152
### 拓扑排序:https://www.cnblogs.com/bigsai/p/11489260.html
### 枚举排序  ?



## 查找

### BFPRT算法

- 相关资料：https://segmentfault.com/a/1190000008322873

- 简介：在一个数组中求其前 k 大或前 k 小的问题，简称 TOP-K 问题。而目前解决 TOP-K 问题最有效的算法即是**BFPRT 算法**，



## 存储

### 链式存储（如链表）和顺序存储（如数组）

- 使用特点
  - 顺序表适宜于做查找这样的静态操作；
  - 链表宜于做插入、删除这样的动态操作。
  - 若线性表的长度变化不大，且其主要操作是查找，则采用顺序表；
  - 若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。

- **基于空间的比较**
  - 存储分配的方式
    - 顺序表的存储空间是静态分配的
    - 链表的存储空间是动态分配的
  - 存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量
    - 顺序表的存储密度 = 1
    - 链表的存储密度 < 1
- **基于时间的比较**
  - 存取方式
    - 顺序表可以随机存取，也可以顺序存取
    - 链表是顺序存取的
  - 插入/删除时移动元素个数
    - 顺序表平均需要移动近一半元素
    - 链表不需要移动元素，只需要修改指针







# SFML

## 什么是SFML

  - SFML 是多媒体库，它为PC的各个组件提供简单的界面，用来简化游戏和多媒体应用程序的开发。 主要由五个模块组成，分别是：系统，窗口，图形，音频和网络。

  - SFML 是跨平台的，通过 SFML，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS以及Android和iOS。

  - SFML 支持多种语言，具体可以在官网查看支持的语言。

    
    

# C++相关
## 类
### 友元函数
- 参考资料:https://www.runoob.com/cplusplus/cpp-friend-functions.html
- 简介:友元函数是定义在类的外部的一个函数，但是可以访问类内的成员，友元函数本身并不是类的成员！！同理还有友元类。使用时在函数前带上friend关键字。

### 内联函数

- 参考资料:https://www.runoob.com/cplusplus/cpp-inline-functions.html
- 简介:内联函数通常与类一起使用，内联函数在编译时，编译器会把该函数出现的地方直接替换为函数的代码段，所以内联函数通常为10行内的小函数，使用时在函数名前带上inline关键字，在类里面定义的成员函数是内联函数，虽然没有inline关键字。注意：内联函数中不要出现递归，循环和开关语句。虚函数和递归函数不能被正常内联
- 优点:函数体较小时，能提高代码效率，对于代码较少的函数推荐使用内联
- 缺点:如果内联函数代码较多，则可能使程序变慢

### 静态成员

- 参考资料:https://www.runoob.com/cplusplus/cpp-static-members.html
- 简介:当类定义中的一个成员是静态成员时，那么无论我们创建多少个该类的对象，静态成员始终只有一个，类似于全局变量，即该类的不同对象访问的是同一个静态成员，不同对象共享一个静态成员。静态成员可以在类的外部通过::来重新初始化该静态成员。使用时在成员前带上static关键字。
- 静态成员函数
  - 静态成员函数即使在没有类的实例对象时也可以调用，方法为: 类名::静态成员函数名
  - 静态成员函数只能访问静态成员数据和其他静态成员函数和类外的其他函数
  - 静态成员函数没有this指针

### 多态

- 参考资料:https://www.runoob.com/cplusplus/cpp-polymorphism.html
- 简介:当子类和父类都有一个同名函数时，对应的子类调用自己类中的这个函数，是多态的一般使用方式。

####    虚函数

- 简介:**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

- 没有主体的虚函数是纯虚函数，这时要在声明后加上"=0",例:virtual int getarea()=0;

  | 摘自别人的笔记:                                              |
  | ------------------------------------------------------------ |
  | 1、纯虚函数声明如下： **virtual void funtion1()=0;** 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。<br />2、虚函数声明如下：**virtual ReturnType FunctionName(Parameter)** 虚函数必须实现，如果不实现，编译器将报错，错误提示为：<br />error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"<br />3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。<br />4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。<br />5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。<br />6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。<br />7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。<br />8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。 |

- 补充:C++中，虚函数可以是private的，并且可以被子类所覆盖，但是子类不能调用父类中private的虚函数。

- | 摘自别人的笔记                                               |
  | ------------------------------------------------------------ |
  | C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。<br />一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。<br />编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！<br />**纯虚函数**可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。 |

### 抽象类

- 参考资料:https://www.runoob.com/cplusplus/cpp-interfaces.html

- 简介:如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。

- 设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的**基类**。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。

  因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。

  可用于实例化对象的类被称为**具体类**。

